1. What is the purpose of the next() function, and how does it contribute to the compilation process?

The next() function plays a key role in the lexical analysis phase of the C4 compiler. It works as a tokenizer, reading the source code character by character and breaking it into meaningful tokens like keywords, identifiers, numbers, and operators. These tokens are essential for the parser, which uses them to analyze and generate intermediate code. The function also handles tasks like skipping whitespace and comments, adding identifiers to the symbol table, and detecting lexical errors. Additionally, it tracks the line number and position in the source code, which helps with debugging and error reporting. By transforming raw source code into structured tokens, next() makes it easier for the later stages of the compilation process to process the code efficiently.

2. How does C4 handle symbol resolution (e.g., variables, functions)?

C4 manages symbol resolution using a symbol table, which is essentially an array storing identifiers and their associated information. Each identifier in the table includes details like its name, type, classification (global variable, local variable, or function), and its value (such as memory address or constant). When the compiler encounters an identifier, it computes a hash value and searches the symbol table for a match. If found, it retrieves the identifierÕs details; otherwise, it adds a new entry. C4 categorizes identifiers into different classes: global variables are stored in the data segment, while local variables are allocated within a functionÕs stack frame. This structured approach ensures that identifiers are managed efficiently during compilation, preventing duplicate declarations within the same scope.
3. What are the limitations of C4 as a compiler? What features of C does it not support?

C4 is a minimalist compiler designed for simplicity and educational use, which means it lacks many advanced features of standard C compilers like GCC. One major limitation is the absence of a preprocessor, so it does not support directives like #include, #define, or #ifdef. It only supports basic data types like int and char, while excluding float, double, struct, union, and enum. Although C4 supports pointers and pointer arithmetic, it does not handle multi-dimensional arrays. The compiler also lacks a standard library, providing only a few built-in functions like printf, malloc, and exit. Another limitation is that C4 does not optimize code, generating basic, unoptimized instructions. Error handling is minimal, as the compiler stops at the first error without detailed diagnostics. Additionally, C4 does not support block-level scoping, treating all variables within a function as local to that function. Features like function pointers and higher-order functions are also missing. Due to these limitations, C4 is not practical for real-world C programming but serves as a great learning tool for understanding compiler design.

4. How does C4 achieve self-hosting (i.e., compiling itself)? What are the implications of this design?

C4 is self-hosting, meaning it is written in a subset of C that it can compile itself. The process begins by using an existing C compiler, like GCC, to compile the C4 source code into an executable. This executable can then be used to compile its own source code, demonstrating that C4 is capable of compiling itself. This technique, called bootstrapping, is an important milestone in compiler development because it verifies that the compiler is functional and reliable. C4Õs ability to self-host is made possible by its minimalistic design, which ensures that it only relies on the features it supports. While this approach confirms the correctness and efficiency of the compiler, it also highlights its limitations since it lacks many modern C features. Despite this, C4 remains a valuable educational tool for learning about compiler design and the bootstrapping process.

